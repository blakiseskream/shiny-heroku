---
title: "Shiny on Heroku"
author: "Andrew Watson"
runtime: shiny
date: "Oct 2021"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
library(pool)
library(RPostgreSQL)
library(shiny)

knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(error = FALSE)
```

## Intro

This tutorial[^1] teaches you how to

  - Host R Shiny applications on the [Heroku](https://heroku.com) platform
  - Apply security to those applications via forced https, OAuth, and nginx
  - Use Heroku Postgres with the apps
  
## Requirements

You'll need to install a lot of software if you haven't already. Let's assume that if you've gotten this far you've installed R + RStudio, but perhaps you haven't installed some of the Heroku specific requirements.

  - [Git](https://git-scm.com/downloads)
  - [Heroku command line tools](https://devcenter.heroku.com/articles/heroku-cli). You'll also need a [Heroku account](https://heroku.com).
  - [latest PostgresQL](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads). **Huge note** when you install this, please make sure you remember your superuser password. For the sake of this tutorial, we will assume you set the password as **admin**.

## Your first Heroku app

Let's get started by creating a simple unsecured Heroku application. The application files are located in the `1. simple unsecured app`() directory of this repository

### Create a new repo, or fork this one.

Either fork this repository by clicking the [fork button](https://github.com/blakiseskream/shiny-heroku#fork-destination-box) on the Github page, or create your own on [Github](https://github.com). I recommend you make your own empty repository on Github, and then follow the below to bring it into RStudio.

If you have Git installed you can clone directly in RStudio by going to

    File > New Project... > Version Control > Git
    
Make sure you are running RStudio with adminsistrator rights if you are on Windows, and make sure you've restarted your computer since installing Git.

### Create a new Shiny application

Once you have your repository built create your Shiny app by going to

    File > New File > Shiny Web App...
    
Name the file as you will (in this example we name it *my-app* and select the `Single File (app.R)` option. 

By default this will create a new folder in your directory with the name of your app. **Move the app.R file out of the new directory and into the main directory of your repository.** Delete the now empty folder that the `app.R` file was in.

You can quickly run your first simple app if you wish by opening the `app.R` file. In RStudio a button should appear in the upper right hand corner with a green triangle that says `Run App`. Alternatively, you can just run the file. You should see the default Shiny app open up with the Geyser's visualization, similar to the below.

***

#### Old Faithful Geyser Data
```{r echo=FALSE}
sliderInput("bins",
  "Number of bins:",
  min = 1,
  max = 50,
  value = 30
)
```


```{r echo=FALSE}
renderPlot({
  # generate bins based on input$bins from ui.R
  x <- faithful[, 2]
  bins <- seq(min(x), max(x), length.out = input$bins + 1)

  # draw the histogram with the specified number of bins
  hist(x, breaks = bins, col = "darkgray", border = "white")
})
```


### Add a `run.R` file

In order to have the application work with Heroku, you will need a `run.R` file. The Heroku app *runs* the `run.R` file once it starts up (woah!). This file does any setup that needs to occur before the app itself is launched. In this first unsecured app with a single file `app.R` the `run.R` file will simply set the port and run the application. To create the `run.R` file go to

    File > New File > R Script
    
Copy + paste in the code below into the file.

```{r eval=FALSE}
# simple run.R
library(shiny)

# Gets the port # from Heroku
port <- Sys.getenv("PORT")

# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# The host of 0.0.0.0 indicates the app runs at the web server's ip address
shiny::runApp(
  appDir = getwd(),
  host = "0.0.0.0",
  port = as.numeric(port)
)
```

Save that shit!

### Have all your files?

Woo! you now have all you need for your first app.

Your file directory should only have the following files in it,

     app.R
     run.R
     some .Rproj file
     .gitignore

If you forked this repository you have some other junk, but those are the essentials. **If you do not see all those files in your repository, go back and carefully re-read these instructions.**

### Commit & Push

Remember, when using R with Github to *commit* and *push*[^4] your work as frequently as possible to avoid losing work, propogating errors, and generally being bad at your job. 

#### Using the nice interface

In RStudio you can do this by selecting

    Tools > Version Control > Commit...
    
Or if you prefer hot keys

    Ctrl + Alt + M

Select the checkboxes next to the files and changes you have made to *Stage* changes for the commit. Write a message in the Commit box then click the `Commit` button. This should run the Git command to commit your changes.

Once your changes are *committed* select the *Push* button to upload those changes to Github. 

#### Using the Terminal (preferred way)

You can also *commit* and *push* by running the commands directly into the `Terminal` window in RStudio.

To open the Terminal either click the Terminal window in the bottom pane of your screen or go to

    Tools > Terminal > Move Focus to Terminal
    
Again, if you prefer hotkeys the command is

    Alt + Shift + T

In the Terminal run the following commands,

To commit (backup) your changes

    $ git add *
    
    $ git commit -m "added app.R and run.R files"
    
Each time you commit, you need to run those two commands. The `-m` option stands for *message*. You can change this based on what you actually changed.

To push (upload) your changes run this command. Remember, `origin` is Git speak for Github.

    $ git push origin
    
When using Heroku, we will be focusing on using the Terminal Git commands.

### Heroku command line tools

Time to upload this shit to Heroku and startup the app. To interact with Heroku we will use the Heroku command line tools, again by using the RStudio Terminal window.

Navigate to the Terminal
    
    Alt + Shift + T
    
Type in `heroku` and hit enter. You should see a large list of base commands pop up. You should always go back to this list when wondering *how the hell do I do this in the Heroku command line?* Remember also, you can find the options, explanation, and examples for any command in heroku by running

    $ heroku help command-name

For example, to figure out how to login you can run

    $ heroku help login
    
#### heroku login

If you are using a simple free Heroku account you can login by using

    $ heroku login
    
and passing in your credentials.


If you have an enterprise heroku account, with single sign on (sso) enabled **hint hint Salesforce employees this is you!** run the following command,

    $ heroku login --sso
  
When it prompts you, add the name of your organization (for Salesforce employees this is `sfdc-aloha`) and then pass in the appropriate access token from the web browser window that opens. Note that when using the Terminal common copy paste commands `Ctrl + V` and `Ctrl + C` are disabled. You need to right click `Paste` to paste items into the Terminal.

#### heroku apps:create

Now that you've hopefully managed to login let's create your first app using the `heroku apps:create` command. Remember, you can see the options of this command by running

    $ heroku help apps:create 
    
This will create a default app in your personal app space simply run the following,

    $ heroku apps:create name-of-your-app

If you are running Heroku Enterprise and have a specific organization (**looking at you F&S**), you can set further parameters by doing
    
    $ heroku apps:create name-of-your-secure-app -t sfdc-gbo-fns
    
If the app has sensitive data, you must apply additional security by creating the app in a Private Space.

    $ heroku apps:create name-of-your-secure-app -t sfdc-gbo-fns --space fns-confidential 
    
Creating an app in a Private Space is *expensive* but will make it incredibly secure. Only do this if hosting app with company confidential and or sensitive data.


#### heroku buildpacks

Now that we've created the app we need to tell Heroku to install R on it. You can instruct Heroku to install certain programs on an app by using **buildpacks.** Heroku has some standard buildpacks, but most of them are created by community members and hosted on Github.

For our apps we are going to start by using the [Heroku buildpack R](https://github.com/virtualstaticvoid/heroku-buildpack-r). Note we are using the heroku-18 version.

<h5 style='color: red'>**STOP**</h5>

Before going on with the tutorial please **EXTENSIVELY** review the documentation on the [buildpack's website](https://github.com/virtualstaticvoid/heroku-buildpack-r). Most of the tutorial will be leveraging information in that documentation, and will assume you have read it.

Okay, now that you've read that, set to build on the Heroku-18 stack (as it is the one used by buildpack's website)

    $ heroku stack:set heroku-18
    

and add the buildpack to the app,

    $ heroku buildpacks:add https://github.com/virtualstaticvoid/heroku-buildpack-r.git
    

### Push to heroku!

Once the buildpack has been added you are good to go. You can push your brand new app directly to heroku by using the following command in the Terminal,

    $ git push heroku master
    

This will create, build, and run your app. You should see the log output while it builds. Eventually you should see the following output or similar

    remote: -----> R 4.0.0 installed successfully!
    remote: -----> Discovering process types
    remote:        Procfile declares types     -> (none)
    remote:        Default types for buildpack -> console, web
    remote:
    remote: -----> Compressing...
    remote:        Done: 235.3M
    remote: -----> Launching...
    remote:        Released v3
    remote:        https://andrews-app.herokuapp.com/ deployed to Heroku
    remote:
    remote: Verifying deploy... done.
    To https://git.heroku.com/andrews-app.git
     * [new branch]      master -> master

This means its done building. You can visit the app by going to the url mentioned at `https://app-url.herokuapp.com deployed to Heroku`.

#### heroku logs

You can also see the log output if it running by using the following command, 

    $ heroku logs --tail
    
Anything with the key `app[web.1]` is the output from R running on your app.
   
***   
 
## Add a firewall

Congrats you now have a working Heroku app. Let's add some necessary security to it **note you should always do this really**. 

### NGINX

We are going to layer a firewall on top by using the reverse proxy web service [NGINX](http://nginx.org/en/). Nginx is a *reverse proxy* which means that it routes incoming requests from web browsers, called http requests, to services running internally on the server. Before it routes those requests, it can do certain validating, filtering, authentication, etc.

In our case, the serivce running on our app is the Shiny app from our `run.R` file. To get nginx to work we simply need to add the buidplack, modify the `run.R` file, and then add an nginx config file.[^5]

#### Add buildpack

Add the heroku nginx buildpack to your existing application to index value 1 by running the following in the Terminal, 

    $ heroku buildpacks:add heroku-community/nginx --index 1
    

This will tell Heroku to install nginx first.

#### Modify `run.R`

Now we need to modify the `run.R` file to run *behind* NGINX. We can modify our existing `run.R` file by replacing it the following code (note `runApp()` has also changed!),

```{r eval=FALSE}
library(shiny)

# When we run nginx we need to change R to point to the /app folder manually
setwd("/app")

# Create a file at the path /tmp/app-initalized
# This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
# If this file is created, nginx will simply wait forever until the app says its running
file.create("/tmp/app-initialized")
port <- "/tmp/nginx.socket"
attr(port, "mask") <- strtoi("117", 8)


# Runs the app in the working directory. By default this will search for an `app.R` file or
# a ui.R + server.R file combination
# In this case the port is now the address to the nginx proxy
shiny::runApp(
  appDir = getwd(),
  port = port
)
```

#### Add a Procfile

Add a file to your directly simply called Procfile (no file extension!). This is a file that tells Heroku what command to run when it starts up. Its a simple file, with only the following line of code,

    web: env FAKECHROOT_EXCLUDE_PATH=/tmp:/bin bin/start-nginx /app/bin/fakechroot /app/bin/fakeroot /app/bin/chroot /app/.root /app/R/lib/R/bin/R -f /app/run.R --gui-none --no-save 
    

#### Add nginx config

We need to add a custom config file so nginx works with Shiny. Create a `config/` subdirectory and the below code into a new file in that directory. The file is named `nginx.conf.erb`. 


    daemon off;
    # Heroku dynos have at least 4 cores.
    worker_processes <%= ENV['NGINX_WORKERS'] || 4 %>;
    
    events {
      use epoll;
      accept_mutex on;
      worker_connections 1024;
    }
    
    http {
      gzip on;
      gzip_comp_level 2;
      gzip_min_length 512;
      
      server_tokens off;
      
      log_format l2met 'measure#nginx.service=$request_time request_id=$http_x_request_id';
      access_log logs/nginx/access.log l2met;
      error_log logs/nginx/error.log;
      
      include mime.types;
      default_type application/octet-stream;
      sendfile on;
      
      # Must read the body in 5 seconds.
      client_body_timeout 5;
      
      upstream app_server {
        server unix:/tmp/nginx.socket fail_timeout=0;
      }
      
      server {
        listen <%= ENV["PORT"] %>;
        server_name _;
        keepalive_timeout 5;
        
        location / {
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $http_host;
          proxy_redirect off;
          proxy_pass http://app_server;
        }
        
        location /websocket/ {
          proxy_pass http://app_server;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "Upgrade";
        }
      }
    }

### Check yo stuff!

Before you *commit* and *push* check to make sure you have all the necessary files. Your folder should now have the following files in it,

     app.R
     run.R
     some .Rproj file
     .gitignore
     Procfile
     config/nginx.conf.erb
     
Does it? good.

### Commit + Push to heroku

Now commit and push your new and improved app to heroku.

    $ git add *
    $ git commit -m "added nginx"
    $ git push heroku master

***

## Adding OAuth

Now that you have an app with a firewall let's add on a final layer of security, OAuth. Ever use a "Login with Facebook" or "Login with Google" or "Login with Salesforce" button? Those are created via OAuth. OAuth is a method of authenticating with a user account on a different service to utilize that service's API, and secure you own personal applications.

This tutorial will walk you through how to add Hadley's [Oauth on Shiny apps](https://gist.github.com/hadley/144c406871768d0cbe66b0b810160528) script to  your `run.R` file.

### How it works

At its basic OAuth works by doing the following,

  1. When a browser request comes in, redirect the browser to the OAuth provider's authentication url (e.g. https://login.salesforce.com/services/oauth2/authorize) with a registered app id (sometimes called client id) and secret code (sometimes called client secret, app secret, consumer secret, etc.)
  
  2. Some magic happens while the user logs in
  
  3. The provider (e.g. Google, Facebook, Salesforce) redirects the user back to the Shiny app, only this time the url contains a secret code called a *token*
  
  4. The app uses the *token* to then query the service for some information. For example, we can ask Github for user profile information by adding the token to the url (called an *endpoint*) https://api.github.com/user 
  
  
The trick here is to have the app run only after a successful *reponse* has been received from the service after step **4**. Then, and only then, do we know for certain that the user has a valid authentication token and was able to login successfully with the service.

### A note on REST and http

Going forward in this tutorial we will be using lots of terms like *GET*, *POST*, *endpoint*, *https*, etc. All of these terms refer to ways that web browsers interact with web servers. At its core, our Shiny app is just a web server, and we need to program it to function as such by using certain things that are built into all web browsers.

A quick guide to the basic terms is,

  - `http`: http is how web browsers and many programs talk to the internet. It is a standard way of communicating across sercvices
  
  - `https`: https is a secure http connection. Terms you will see associated with this are also `SSL`, `TLS`, *certificate*, etc. All of this just refers to a secure http connection between a browser and a web server. All modern web pages are hosted on **https**, easily identified by the `Secure` flag in the upper left hand side of your url bar.
  
  - `IP Address`: hopefully you know this, but an IP address is the location of a web server on the open internet. In the modern internet, IP addresses of things usually change a lot, especially services on cloud solutions such as Heroku. The IP address for your local computer is always `127.0.0.1` or simply `localhost`.
  
  - `Domain name`: the way that we know where a given application is at any point in time is via the `domain name`. Even if the IP adress of a server is constantly changing, the `domain name` should always point to the correct IP. By default on heroku all apps are given a domain of `https://app-name.herokuapp.com`. When you type that into the browser, it evaluates as an IP address and sends your computer there.

  - `Port`: a port is a number associated with an IP address on a webserver. The IP address is the location of the web server, however that web server may have multiple services it is hosting (many apps). You can access specific apps on a webserver at a specific IP address by specifying the port number. Shiny for example may be on a webserver with IP address `275.219.201.189`  but running on port `8080`. The address to that Shiny app is then `https://275.291.201.189:8080`. When testing on your computer you can define a specific port to run Shiny on (normally anything above 4000). You can then access the app while its running in your web browser. For example, a Shiny app runnning on your local computer on port `8000` will have the address `http://localhost:8000`. 
  
  - `GET`: a `GET` request is an http request *asking* for data. When you go to `https://heroku.com` you are performing a `GET` request to ask for the web pages information. That information is then downloaded to your browser and displayed for you. **Anytime you ask a URL for data you perform a GET request**
  
  - `POST`: a `POST` request is a http request to *submit* data into a server. For example, when you fill in a form and click the *submit* button on a website, it performs a `POST` request to the server saying "hey, I got some data here, can you save it?."
  
  - `Endpoint`: an endpoint is just a fancy name for a URL. Specifically, its a URL where you can ask for specific information to work with your program through a services API. Again, the example is to ask Github for user profile info we would go to the `endpoint` https://api.github.com/user 
  
  - `API`: API stands for *application programming interface* its a set of easy to use commands, endpoints, etc. that are written in a easy to use common language. This allows you to use something like R to interact with Google Sheets by using the Google Sheets API. R and Google Sheets talk to each other via a commonly known language, in this case a REST API.
  
  - `REST`: a REST API is an API that communicates to a program via `GET` and `POST` requests to a serviuce such as Google, Facebook, Salesforce, etc. These services create different URLs that you can query via `GET` requests to get different information. For example, in the [Salesforce REST API](https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/intro_what_is_rest_api.htm) we can do things like pull down Chatter posts, investigate opportunities, view profile info, etc. REST APIs are incredibly common and most major services have them, because they work over `http` almost every single language can use them.
  
  - `httr`: [httr](https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html) is the R package for doing all the things listed above. **I recommend reading the docs on httr** its incredibly useful, and unlocks the ability to use R with many web services.

### Setup

Now that you've reviewed your terms and have a little bit more familiarity with how internet applications work lets setup an OAuth wall in front of our existing app. This first pass OAuth will setup using an existing Github app's information. Once we have that working, we will guide you through how to set it up on your own.

This app is based almost entirely on a Gist authored by Hadley [here](https://gist.github.com/hadley/144c406871768d0cbe66b0b810160528)

### install packages with `init.R`

In order to make OAuth work we need to install the [httr](https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html) package. To install packages on the Heroku buildpack add a file named `init.R` to your folder. Copy and paste in the code below into that file.

```{r eval=FALSE}
# Add a list of packages you want to install here
# The list, like every list in R, should be comma seperated
# Package names in quotes, e.g. c("lubridate","httr","dplyr")
my_packages <- c("httr")


# This is a simple function that will install the packages in the list
install_if_missing <- function(p) {
  if (p %in% rownames(installed.packages()) == FALSE) {
    install.packages(p)
  }
}

# run the function
invisible(sapply(my_packages, install_if_missing))
```

This file is required if you want to install any packages on the Herku app that aren't in the default build (basically everything except Shiny).

### Remove run line from `app.R`

We are going to pass more of the control of the app over to our `run.R` file. In order to do this properly, we will need to remove a line of code from our existing `app.R` file, or else the two shall conflict.

To do this, simply comment, or remove this line from your `app.R` file,

```{r}
# Run the application
# shinyApp(ui = ui, server = server)
```

### Modify `run.R`

The OAuth powerhouse is the `run.R` file. Here we take our existing `run.R` file, and wrap it in a series of functions and setps so that it does the redirect and validates the user is authenticated *before* launching the rest of the app. 

Furthermore, we have to `source()` the `app.R` file because we need to wrap the `ui` portion into a new `uiFunc` which prevents creation of the `ui` until the oauth is complete.

Copy and paste the code below, *in its entirety* into your `run.R` file.

```{r eval=FALSE}
# TODO: To get this to work on Heroku you will need to fill out the info,
# set APP_URL to your heroku apps url
# set key = to the Github application's Client ID
# set secret = to the Github application's Client Secret
# Create a Github OAuth app here https://github.com/settings/applications/new

library(shiny)
library(httr)

RunHerokuApp <- function() {

  # OAuth setup --------------------------------------------------------
  # (1) Most OAuth applications require that you redirect to a fixed and known
  # set of URLs. Many only allow you to redirect to a single URL: if this
  # is the case for, you'll need to create an app for testing with a localhost
  # url, and an app for your deployed app.

  if (interactive()) {
    # testing url and token
    options(shiny.port = 8100)
    APP_URL <- "http://localhost:8100/"

    # (2) Note that secret is not really secret, and it's fine to include inline
    app <- oauth_app("shiny-local-app",
      key = "51d46f96810d1fd182a2",
      secret = "66eec8782825eeb61007dbef32f91afc9c3587aa",
      redirect_uri = APP_URL
    )
  } else {
    setwd("/app")

    # deployed URL and token
    APP_URL <- "https://my-app-name.herokuapp.com/" # NOTE: SET THIS TO YOUR APP'S URL

    # (2) Note that secret is not really secret, and it's fine to include inline
    # NOTE: SET THIS BASED ON YOUR GITHUB APP.
    app <- oauth_app("my-heroku-app",
      key = "MY_APP_ID",
      secret = "MY_SECRET_KEY",
      redirect_uri = APP_URL
    )
  }

  # (3) Here I'm using a canned endpoint, but you can create with oauth_endpoint()
  api <- oauth_endpoints("github")

  # (4) Always request the minimal scope needed. For github, an empty scope
  # gives read-only access to public info
  scope <- ""

  # Shiny -------------------------------------------------------------------

  # Bring in the server.R and ui.R objects
  source("app.R")

  has_auth_code <- function(params) {
    # params is a list object containing the parsed URL parameters. Return TRUE if
    # based on these parameters, it looks like auth codes are present that we can
    # use to get an access token. If not, it means we need to go through the OAuth
    # flow.
    return(!is.null(params$code))
  }

  # (5) A little-known feature of Shiny is that the UI can be a function, not just
  # objects. You can use this to dynamically render the UI based on the request.
  # We're going to pass this uiFunc, not ui, to shinyApp(). If you're using
  # ui.R/server.R style files, that's fine too--just make this function the last
  # expression in your ui.R file.
  uiFunc <- function(req) {

    # (6) Check if HTTPs
    if (!interactive()) {
      if (req$HTTP_X_FORWARDED_PROTO != "https") {
        return("ERROR: Not HTTPS")
      }
    } else {
      print("localhost app, not verifying https")
    }

    # (7) Check if token in URL, else redirect
    if (!has_auth_code(parseQueryString(req$QUERY_STRING))) {
      url <- oauth2.0_authorize_url(api, app, scope = scope)
      redirect <- sprintf("location.replace(\"%s\");", url)
      tags$script(HTML(redirect))
    } else {

      # (8) Manually create a token (saved to local environment)
      token <<- oauth2.0_token(
        app = app,
        endpoint = api,
        credentials = oauth2.0_access_token(
          api,
          app,
          parseQueryString(req$QUERY_STRING)$code
        ),
        cache = FALSE
      )

      # (9) Perform a GET request to confirm access
      resp <- GET("https://api.github.com/user", config(token = token))
      stop_for_status(resp) # CRASH APP IF ERROR RETURNED

      return(ui) # otherwise return UI
    }
  }

  # (10) Note that we're using uiFunc, not ui!
  if (interactive()) {

    # run locally
    shinyApp(uiFunc, server)
  } else {

    # Create a file at the path /tmp/app-initalized
    # This tells nginx that the app is running, and it can now forward traffic to the custom 'port' below
    # If this file is created, nginx will simply wait forever until the app says its running
    file.create("/tmp/app-initialized")
    port <- "/tmp/nginx.socket"
    attr(port, "mask") <- strtoi("117", 8)


    # Runs the app in the working directory. By default this will search for an `app.R` file or
    # a ui.R + server.R file combination
    # In this case the port is now the address to the nginx proxy
    shiny::runApp(
      appDir = shinyApp(uiFunc, server),
      port = port
    )
  }
}

RunHerokuApp()
```

#### Run it locally

Try now running this file, you should see a login prompt appear asking you to login to Github. Woo!

### Setup Github OAuth app

To get it to run on Heroku however, you need to setup your own Github OAuth application that works with your app's URL. To do that first, if you haven't already, create a *public* [Github account](https://github.com/join). Note that this is different than a Github Enterprise account, which is a *private* account.

Once you've created a Github account, create a new Github OAuth account [here](https://github.com/settings/applications/new).

Fill out the information. The most important part is that you set the `Authorization callback URL` to the URL of your Heroku application.

Once you create the app you will notice that your `Client Secret` and `Client ID` are now available.

Go back to your `run.R` and pop those bad boys into the `oauth_app()` part,

```{r eval=FALSE}
# deployed URL and token
APP_URL <- "https://my-app-name.herokuapp.com/" # NOTE: SET THIS TO YOUR APP'S URL

# (2) Note that secret is not really secret, and it's fine to include inline
# NOTE: SET THIS BASED ON YOUR GITHUB APP.
app <- oauth_app("my-heroku-app",
  key = "MY_APP_ID",
  secret = "MY_SECRET_KEY",
  redirect_uri = APP_URL
)
```

### Commit & Push

Push that up to Heroku. Remember to check your logs

    heroku logs --tail
    
To verify, and perform an error tests. To see heroku logs specifically related to the web app, apply the `-d` parameter,

    heroku logs --tail -d web.1
    
### Move secret & client to environment variables

Now you will want to have your `APP_ID` and `CLIENT_SECRET` to be enviornment variables. You can set them as environment variables by going to the [Heroku dashboard](https://dashboard.heroku.com) for your app and then

    Settings > Reveal Config Vars > Add
  
Type in the name of the variable in `KEY` and the value in `VALUE`.

Read more about environment variables on Heroku [here](https://devcenter.heroku.com/articles/config-vars).

In R you can add the environment variables to your app by again modifying the code to,

```{r eval=FALSE}
# deployed URL and token
APP_URL <- Sys.getenv("APP_URL") # Set this variable on heroku!

# register app
app <- oauth_app("my-heroku-app",
  key = Sys.getenv("APP_ID"), # set this on HerokU!
  secret = Sys.getenv("CLIENT_SECRET"), # set this on Heroku!
  redirect_uri = APP_URL
)
```

***

## Adding Postgres

[Postgres](https://www.postgresql.org/) is an open source SQL database. With Postgres we can host massive amounts of data behind our Shiny applications without slowing down the performance of the app itself. We can also do data manipulation and management via SQL / [dblyr](https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html), which unlocks the full power of R.

Before you begin this section it is recommended you go back to the top and install Postgres onto your local computer. This tutorial however will work perfectly even if you do not have Postgres installed on your local computer.

### Postgres + Heroku

Heroku has extensive Postgres documentation [here](https://devcenter.heroku.com/articles/heroku-postgresql). Refer to this on how to provision (create) the database on Heroku itself, work with the database, and do all kinds of fun things.

To quickly add a Postgres database to your Heroku app go [here](https://elements.heroku.com/addons/heroku-postgresql) and select `Install Heroku Postgres`.

Make sure you understand the various plans / levels, and select the database specific to your needs. 

#### Note on Privacy

If the database is housing private or company confidential information make sure you have the Postgres provisioned to an app that is on a Private Space by default the lowest Heroku Postgres Private Space plan includes 64 GB of data. Which should be plenty for advanced R Shiny applications.

### R Postgres Packages

To work with R you will need to install two packages onto the app

  - [RPostgreSQL](https://www.r-bloggers.com/getting-started-with-postgresql-in-r/)
  - [pool](https://github.com/rstudio/pool)

As always, I advise reading the documentation to understand these packages.

#### add to `init.R`

Remember you will need to add these to `init.R` in order to install. With `pool` we will install the development version directly from Github. 

In order to do this we add the `devtools` package, and add `devtools::install_github("rstudio/pool")` to the end.

```{r}
# init.R
my_packages <- c("httr", "RPostgreSQL", "devtools")

install_if_missing <- function(p) {
  if (p %in% rownames(installed.packages()) == FALSE) {
    install.packages(p)
  }
}

invisible(sapply(my_packages, install_if_missing))

# install pool from Github
invisible(devtools::install_github("rstudio/pool"))
```

#### include `Aptfile`

For `RPostgreSQL` to install we need to install some files to the linux system on Heroku. We can do this by providing a file named `Aptfile`. Like `Procfile` this file has **no extension**,

Save `Aptfile` to your file directory with the two lines of code,

    libpq-dev
    libxml2-dev

Please read more about `Aptfile` on the Heroku R buildpack Github [here](https://github.com/virtualstaticvoid/heroku-buildpack-r#installing-binary-dependencies)

### Connecting via Shiny

Once the database has been created on Heroku it adds an [environment variable](https://devcenter.heroku.com/articles/config-vars) called `DATABASE_URL`. This is the URL to connect to the Heroku database.

You can access it via R by using the following function in your Shiny app.

```{r}
postgress.connect <- function() {

  # Make sure you install these!
  require(RPostgreSQL)
  require(pool)

  # driver
  drv <- dbDriver("PostgreSQL")

  # attempt connection
  if (Sys.getenv("DATABASE_URL") != "") {
    url <- httr::parse_url(Sys.getenv("DATABASE_URL"))
    pool <- dbPool(drv,
      host = url$hostname,
      port = url$port,
      user = url$user,
      password = url$password,
      dbname = url$path
    )
    print("Heroku application detected connecting to Postgres")
  } else {
    # You would setup a localhost  db connection to your personal computer here!
  }

  return(pool)
}
```

And then invoke the function when you need to connect to the database,

```{r}
pg <- postgress.connect()
```

### Example, saving data

For example, you can modify your `app.R` to include a file upload button, and then a save to Postgres. Based almost entirely on this script [here](https://shiny.rstudio.com/gallery/file-upload.html).

```{r eval=FALSE}
# app.R
library(shiny)
library(RPostgreSQL)
library(pool)


# Define UI for application that draws a histogram
ui <- fluidPage(

  # Application title
  titlePanel("File upload"),

  # Sidebar with a slider input for number of bins
  sidebarLayout(
    sidebarPanel(
      fileInput("file1", "Choose CSV File",
        multiple = FALSE,
        accept = c(
          "text/csv",
          "text/comma-separated-values,text/plain",
          ".csv"
        )
      ),
      actionButton("viewData", label = "View data")
    ),

    # Show a plot of the generated distribution
    mainPanel(
      tableOutput("postgresTable")
    )
  )
)

# Define server logic required to draw a histogram
server <- function(input, output) {
  postgress.connect <- function() {
    # driver
    drv <- dbDriver("PostgreSQL")
    # attempt connection
    if (Sys.getenv("DATABASE_URL") != "") {
      url <- httr::parse_url(Sys.getenv("DATABASE_URL"))
      pool <- dbPool(drv,
        host = url$hostname,
        port = url$port,
        user = url$user,
        password = url$password,
        dbname = url$path
      )
      print("Heroku application detected connecting to Postgres")
    } else {
      # SETUP local connection here
    }
    return(pool)
  }


  # File upload event listener
  observeEvent(input$file1, {
    # input$file1 will be NULL initially.
    req(input$file1)

    # check to make sure an error doesn't occur
    tryCatch(
      {
        df <- read.csv(input$file1$datapath)
        # create connection
        pg <- postgress.connect()
        # remove table if exists
        try(dbRemoveTable(pg, "upload_table"))
        # write a new table
        dbWriteTable(pg, "upload_table", df, temporary = FALSE)
        # close connection
        pool::poolClose(pg)
      },
      error = function(e) {
        # return a safeError if a parsing error occurs
        stop(safeError(e))
      }
    )
  })

  # create a reactive object for the database
  pgData <- eventReactive(input$viewData, {
    # create connection
    pg <- postgress.connect()
    # read data
    data <- dbReadTable(pg, "upload_table")
    # close connection
    pool::poolClose(pg)
    # return data
    return(data)
  })

  output$postgresTable <- renderTable({
    pgData()
  })
}
```

It should work like the below,

```{r echo=FALSE}
fileInput("file1", "Choose CSV File",
  multiple = FALSE,
  accept = c(
    "text/csv",
    "text/comma-separated-values,text/plain",
    ".csv"
  )
)
actionButton("viewData", label = "View data")
```

```{r echo=FALSE}
postgress.connect <- function() {
  # driver
  drv <- dbDriver("PostgreSQL")
  # attempt connection
  if (Sys.getenv("DATABASE_URL") != "") {
    url <- httr::parse_url(Sys.getenv("DATABASE_URL"))
    pool <- dbPool(drv,
      host = url$hostname,
      port = url$port,
      user = url$user,
      password = url$password,
      dbname = url$path
    )
    print("Heroku application detected connecting to Postgres")
  } else {
    # SETUP local connection here
  }
  return(pool)
}


# File upload event listener
observeEvent(input$file1, {
  # input$file1 will be NULL initially.
  req(input$file1)

  # check to make sure an error doesn't occur
  tryCatch(
    {
      df <- read.csv(input$file1$datapath)
      # create connection
      pg <- postgress.connect()
      # remove table if exists
      try(dbRemoveTable(pg, "upload_table"))
      # write a new table
      dbWriteTable(pg, "upload_table", df, temporary = FALSE)
      # close connection
      pool::poolClose(pg)
    },
    error = function(e) {
      # return a safeError if a parsing error occurs
      stop(safeError(e))
    }
  )
})

# create a reactive object for the database
pgData <- eventReactive(input$viewData, {
  # create connection
  pg <- postgress.connect()
  # read data
  data <- dbReadTable(pg, "upload_table")
  # close connection
  pool::poolClose(pg)
  # return data
  return(data)
})

renderTable({
  pgData()
})
```

***
## Hosting an RMarkdown as an app

If you want to host an [interactive RMarkdown](https://rmarkdown.rstudio.com/authoring_shiny.html) on Heroku simply replace your final `runApp()` call in `run.R` with the following,

```{r eval=FALSE}
# Add as final run call in your run.R
rmarkdown::run(
  "my-markdown.Rmd",
  shiny_args = list(
    port = port
  )
)
```

If you need this to sit behind OAuth consider adding it to the `uiFunc` or refer to this Stack Overflow article [here](https://stackoverflow.com/questions/33499651/rmarkdown-in-shiny-application)

Also refer to the repository behind this app [here](https://github.com/blakiseskream/shiny-heroku) as an example

***

## Going further

Congratulations! You know have the knowledge necessary to build a Shiny application on Heroku with security and database support. In doing this you probably will run into many errors. I advise you Google, Google, and Google. Heroku has extensive documentation on just about anything, and there are R packages out there that can also help you do anything.

Have fun, stay safe.

Andrew.


[^1]: I will leave the debate as to whether or not Heroku is an effective platform for hosting Shiny Apps to the cynics. For beginners, its super easy, and allows for database backend / more customizability than options such as ShinyApps.io. You can also layer on more advanced security features, add-ons, etc. 

[^4]: In Git speak to *commit* something is to save and back it up. To *push* is to upload that latest backup (*commit*) to the internet (i.e. Github), Github is referred to as *origin*. You can upload to different places on the internet by adding other *remotes*. A *remote* is simply a location on the internet you are uploading your code to. 

[^5]: Note the original instructions for this are authored by yours truly [in the issues log](https://github.com/virtualstaticvoid/heroku-buildpack-r/issues/116#issuecomment-386169880) of the r buildpack.
